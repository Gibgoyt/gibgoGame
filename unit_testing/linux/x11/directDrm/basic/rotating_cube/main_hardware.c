/*
 * gibgoCraft - Hardware-Direct 3D Rotating Cube Rendering
 *
 * This is the REVOLUTIONARY version that completely replaces Vulkan with
 * direct GPU hardware access! Now with full 3D support!
 *
 * CUSTOM TYPE SYSTEM: Uses ZERO native C types for complete memory control!
 * HARDWARE DIRECT: Talks directly to GPU registers - NO DRIVERS!
 * 3D GRAPHICS: Full matrix transformations, depth testing, and animation!
 */

#define _GNU_SOURCE  // Enable usleep and other POSIX extensions
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// Custom type system - ABSOLUTE MEMORY CONTROL
#include "types.h"
#include "math.h"

// X11 includes
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/keysym.h>

// OUR CUSTOM HARDWARE-DIRECT GRAPHICS API!
#include "gibgo_graphics.h"
#include "gpu_device.h"  // For internal GPU types

// 3D Graphics components
#include "cube_geometry.h"
#include "uniform_buffer.h"
#include "camera.h"
#include "animation.h"

// Constants
#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600
#define APP_NAME "gibgoCraft - Hardware-Direct 3D Rotating Cube"

// Note: Using GibgoVertex from gibgo_graphics.h now (which has Vec3f position)

// Application context
typedef struct {
    // X11 windowing
    Display* display;
    Window window;
    Atom wm_delete_window;
    b32 should_close;

    // X11 graphics context for displaying framebuffer
    GC gc;
    XImage* ximage;
    Visual* visual;
    int screen;

    // OUR CUSTOM GRAPHICS SYSTEM!
    GibgoGraphicsSystem* graphics;

    // 3D Rendering components
    Camera camera;
    CubeAnimation animation;
    GibgoUniformBuffer uniform_data;
    u64 uniform_buffer_address;     // GPU memory address for uniform buffer

    // Frame timing
    u32 frame_count;
} AppContext;

// Cube triangle list (36 vertices for 12 triangles)
// Generated from indexed cube geometry for immediate mode rendering
static GibgoVertex cube_triangle_vertices[CUBE_INDEX_COUNT];
static u32 cube_vertex_count = 0;

// Compiled SPIR-V shader bytecode (same as Vulkan version for compatibility)
// Generated by compile_shaders_hardware.sh
extern const u32 vertex_shader_spirv[];
extern const u32 vertex_shader_spirv_size;
extern const u32 fragment_shader_spirv[];
extern const u32 fragment_shader_spirv_size;

// Function prototypes
static b32 init_x11(AppContext* ctx);
static b32 init_graphics(AppContext* ctx);
static void handle_events(AppContext* ctx);
static void render_frame(AppContext* ctx);
static void cleanup(AppContext* ctx);
static void run_main_loop(AppContext* ctx);

// X11 window initialization
static b32 init_x11(AppContext* ctx) {
    printf("[X11] Initializing window system...\n");

    ctx->display = XOpenDisplay(NULL);
    if (!ctx->display) {
        fprintf(stderr, "Failed to open X11 display\n");
        return B32_FALSE;
    }

    i32 screen = DefaultScreen(ctx->display);
    u32 border_color = BlackPixel(ctx->display, screen);
    u32 background_color = BlackPixel(ctx->display, screen);

    ctx->window = XCreateSimpleWindow(
        ctx->display,
        RootWindow(ctx->display, screen),
        100, 100,                           // x, y
        WINDOW_WIDTH, WINDOW_HEIGHT,        // width, height
        2,                                  // border width
        border_color,
        background_color
    );

    XStoreName(ctx->display, ctx->window, APP_NAME);

    // Set up window close event
    ctx->wm_delete_window = XInternAtom(ctx->display, "WM_DELETE_WINDOW", False);
    XSetWMProtocols(ctx->display, ctx->window, &ctx->wm_delete_window, 1);

    XSelectInput(ctx->display, ctx->window, KeyPressMask | StructureNotifyMask);
    XMapWindow(ctx->display, ctx->window);

    printf("[X11] Window created successfully - %dx%d\n", WINDOW_WIDTH, WINDOW_HEIGHT);
    return B32_TRUE;
}

// Initialize our CUSTOM hardware-direct 3D graphics system!
static b32 init_graphics(AppContext* ctx) {
    printf("\n=== INITIALIZING HARDWARE-DIRECT 3D GRAPHICS ===\n");
    printf("This is NOT Vulkan - this is DIRECT GPU 3D CONTROL!\n");
    printf("Full 3D: Matrix math, depth testing, cube geometry!\n");
    printf("================================================\n\n");

    // Create initialization parameters
    GibgoGraphicsInitInfo init_info = {0};
    init_info.window_width = WINDOW_WIDTH;
    init_info.window_height = WINDOW_HEIGHT;
    init_info.x11_display = ctx->display;
    init_info.x11_window = ctx->window;
    init_info.enable_debug = 1; // Enable all debug output

    // Initialize our custom graphics system
    GibgoGraphicsResult result = gibgo_initialize_graphics(&init_info, &ctx->graphics);
    if (result != GIBGO_SUCCESS) {
        fprintf(stderr, "Failed to initialize graphics system: %s\n",
                gibgo_graphics_result_string(result));
        return B32_FALSE;
    }

    printf("üöÄ SUCCESS! Hardware-direct 3D graphics initialized!\n");

    // Initialize X11 graphics context for framebuffer display
    ctx->screen = DefaultScreen(ctx->display);
    ctx->visual = DefaultVisual(ctx->display, ctx->screen);
    ctx->gc = XCreateGC(ctx->display, ctx->window, 0, NULL);

    // Create XImage for framebuffer display
    ctx->ximage = XCreateImage(ctx->display, ctx->visual, 24, ZPixmap, 0,
                              NULL, WINDOW_WIDTH, WINDOW_HEIGHT, 32, 0);
    if (!ctx->ximage) {
        fprintf(stderr, "Failed to create XImage for framebuffer display\n");
        return B32_FALSE;
    }

    // Allocate XImage data buffer
    ctx->ximage->data = malloc(ctx->ximage->bytes_per_line * ctx->ximage->height);
    if (!ctx->ximage->data) {
        fprintf(stderr, "Failed to allocate XImage data buffer\n");
        return B32_FALSE;
    }

    printf("‚úÖ X11 graphics context initialized\n");

    // Generate cube triangle list from indexed geometry
    cube_generate_triangle_list(cube_triangle_vertices, &cube_vertex_count);
    printf("üé≤ Cube geometry generated: %u vertices for 12 triangles\n", cube_vertex_count);

    // Initialize 3D camera system
    ctx->camera = camera_create_default();
    camera_set_aspect_ratio(&ctx->camera, f32_div(f32_from_native((float)WINDOW_WIDTH),
                                                   f32_from_native((float)WINDOW_HEIGHT)));
    printf("üì∑ Camera system initialized (position: 0,0,5 looking at origin)\n");

    // Initialize cube animation (0.5 rotations per second)
    ctx->animation = animation_create(f32_from_native(0.5f));
    printf("üé¨ Animation system initialized (0.5 rotations/sec)\n");

    // Initialize uniform buffer data
    uniform_buffer_initialize(&ctx->uniform_data);
    uniform_buffer_set_camera_position(&ctx->uniform_data, &ctx->camera.position);
    printf("üì¶ Uniform buffer initialized\n");

    // Load SPIR-V shaders for 3D rendering
    result = gibgo_create_shaders_from_spirv(ctx->graphics,
                                           vertex_shader_spirv, vertex_shader_spirv_size,
                                           fragment_shader_spirv, fragment_shader_spirv_size);
    if (result != GIBGO_SUCCESS) {
        fprintf(stderr, "Failed to load 3D shaders: %s\n", gibgo_graphics_result_string(result));
        return B32_FALSE;
    }
    printf("üîß 3D SPIR-V shaders loaded (vertex + fragment with MVP uniform buffer)\n");

    // Upload cube vertex data to GPU
    result = gibgo_upload_vertex_data(ctx->graphics, cube_triangle_vertices, cube_vertex_count);
    if (result != GIBGO_SUCCESS) {
        fprintf(stderr, "Failed to upload cube vertices: %s\n", gibgo_graphics_result_string(result));
        return B32_FALSE;
    }
    printf("üéØ Cube vertex data uploaded to GPU (%u vertices)\n", cube_vertex_count);

    printf("\nüéä 3D Graphics pipeline ready for HARDWARE-DIRECT cube rendering!\n\n");
    return B32_TRUE;
}

// Handle X11 events
static void handle_events(AppContext* ctx) {
    XEvent event;

    while (XPending(ctx->display)) {
        XNextEvent(ctx->display, &event);

        switch (event.type) {
            case KeyPress: {
                KeySym keysym = XLookupKeysym(&event.xkey, 0);
                if (keysym == XK_Escape) {
                    ctx->should_close = B32_TRUE;
                } else if (keysym == XK_space) {
                    // Print debug info when space is pressed
                    printf("\nüîç DEBUG INFO (Frame %u):\n", ctx->frame_count);
                    gibgo_debug_dump_gpu_state(ctx->graphics);
                } else if (keysym == XK_s) {
                    // Print statistics when 's' is pressed
                    u64 frames_rendered, commands_submitted;
                    gibgo_get_frame_statistics(ctx->graphics, &frames_rendered, &commands_submitted);
                    printf("\nüìä STATISTICS:\n");
                    printf("  Frames rendered: %lu\n", frames_rendered);
                    printf("  Commands submitted: %lu\n", commands_submitted);
                    printf("  Average commands/frame: %.2f\n",
                           frames_rendered > 0 ? (double)commands_submitted / frames_rendered : 0.0);
                    printf("\n");
                }
                break;
            }
            case ClientMessage:
                if ((Atom)event.xclient.data.l[0] == ctx->wm_delete_window) {
                    ctx->should_close = B32_TRUE;
                }
                break;
        }
    }
}

// Copy framebuffer to X11 window for display
static void copy_framebuffer_to_x11(AppContext* ctx) {
    // Get the actual GPU framebuffer data from the graphics system
    // Access the internal context to get the DRM framebuffer
    GibgoGraphicsSystem* system = ctx->graphics;
    if (!system || !system->is_initialized) {
        return;
    }

    // Access internal context (this is a direct approach for now)
    GibgoContext* internal_ctx = (GibgoContext*)system->internal_context;
    if (!internal_ctx) {
        return;
    }

    // Get the GPU device to access the framebuffer
    GibgoGPUDevice* device = (GibgoGPUDevice*)system->internal_device;
    if (!device || !device->regs.registers) {
        return;
    }

    // The DRM framebuffer is stored in device->regs.registers (we repurposed this field)
    u32* gpu_framebuffer = (u32*)device->regs.registers;
    u32* ximage_pixels = (u32*)ctx->ximage->data;

    // Copy GPU framebuffer to XImage (direct memory copy)
    for (int y = 0; y < WINDOW_HEIGHT; y++) {
        for (int x = 0; x < WINDOW_WIDTH; x++) {
            int index = y * WINDOW_WIDTH + x;
            ximage_pixels[index] = gpu_framebuffer[index];
        }
    }

    // Display in X11 window
    XPutImage(ctx->display, ctx->window, ctx->gc, ctx->ximage,
              0, 0, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
    XFlush(ctx->display);
}

// Render a 3D rotating cube using DIRECT GPU HARDWARE!
static void render_frame(AppContext* ctx) {
    GibgoGraphicsResult result;

    // Update animation
    animation_update(&ctx->animation);

    // Update camera matrices if needed
    camera_update_matrices(&ctx->camera);

    // Build model matrix (rotation from animation)
    Mat4f model_matrix = animation_get_rotation_matrix(&ctx->animation);

    // Get camera matrices
    const Mat4f* view_matrix = camera_get_view_matrix(&ctx->camera);
    const Mat4f* projection_matrix = camera_get_projection_matrix(&ctx->camera);

    // Update uniform buffer with new transformation matrices
    uniform_buffer_update_matrices(&ctx->uniform_data, &model_matrix, view_matrix, projection_matrix);
    uniform_buffer_set_time(&ctx->uniform_data, ctx->animation.current_time);

    // Begin frame
    result = gibgo_begin_frame(ctx->graphics);
    if (result != GIBGO_SUCCESS) {
        fprintf(stderr, "Failed to begin frame: %s\n", gibgo_graphics_result_string(result));
        return;
    }

    // Upload updated uniform buffer data to GPU
    result = gibgo_set_uniform_buffer_data(ctx->graphics, &ctx->uniform_data, sizeof(GibgoUniformBuffer));
    if (result != GIBGO_SUCCESS) {
        fprintf(stderr, "Failed to upload uniform buffer: %s\n", gibgo_graphics_result_string(result));
        return;
    }

    // Draw our rotating cube using DIRECT HARDWARE COMMANDS!
    // Draw all 36 vertices (12 triangles) of the cube
    result = gibgo_draw_primitives(ctx->graphics, cube_vertex_count, 0);
    if (result != GIBGO_SUCCESS) {
        fprintf(stderr, "Failed to draw cube: %s\n", gibgo_graphics_result_string(result));
        return;
    }

    // End frame and present to screen
    result = gibgo_end_frame_and_present(ctx->graphics);
    if (result != GIBGO_SUCCESS) {
        fprintf(stderr, "Failed to end frame: %s\n", gibgo_graphics_result_string(result));
        return;
    }

    // Wait for completion
    result = gibgo_wait_for_frame_completion(ctx->graphics);
    if (result != GIBGO_SUCCESS) {
        fprintf(stderr, "Failed to wait for frame: %s\n", gibgo_graphics_result_string(result));
        return;
    }

    // Copy the rendered framebuffer to X11 window for display
    copy_framebuffer_to_x11(ctx);

    ctx->frame_count++;

    // Print periodic status
    if (ctx->frame_count % 60 == 0) {
        printf("üé® Frame %u rendered via DIRECT GPU HARDWARE\n", ctx->frame_count);
    }
}

// Main rendering loop
static void run_main_loop(AppContext* ctx) {
    printf("\nüéÆ Starting hardware-direct rendering loop...\n");
    printf("Controls:\n");
    printf("  ESC   - Exit\n");
    printf("  SPACE - Debug info\n");
    printf("  S     - Statistics\n\n");

    while (!ctx->should_close) {
        handle_events(ctx);
        render_frame(ctx);

        // Small delay to prevent 100% CPU usage
        usleep(16667); // ~60 FPS
    }
}

// Cleanup everything
static void cleanup(AppContext* ctx) {
    printf("\nüßπ Cleaning up hardware-direct graphics system...\n");

    // Shutdown our custom graphics system
    if (ctx->graphics) {
        gibgo_shutdown_graphics(ctx->graphics);
        ctx->graphics = NULL;
    }

    // Cleanup X11
    if (ctx->ximage) {
        if (ctx->ximage->data) {
            free(ctx->ximage->data);
            ctx->ximage->data = NULL;
        }
        XDestroyImage(ctx->ximage);
        ctx->ximage = NULL;
    }

    if (ctx->gc && ctx->display) {
        XFreeGC(ctx->display, ctx->gc);
    }

    if (ctx->window) {
        XDestroyWindow(ctx->display, ctx->window);
    }

    if (ctx->display) {
        XCloseDisplay(ctx->display);
    }

    printf("‚úÖ Cleanup complete!\n");
}

// Main entry point
int main(void) {
    printf("üöÄ gibgoCraft - Hardware-Direct GPU Triangle Demo\n");
    printf("================================================\n");
    printf("This demo bypasses ALL graphics drivers!\n");
    printf("Direct hardware access for MAXIMUM CONTROL!\n");
    printf("================================================\n\n");

    AppContext ctx = {0};

    // Verify our custom types work correctly
    printf("üîß Custom type verification:\n");
    printf("  f32 size: %lu bytes\n", sizeof(f32));
    printf("  Vec2f size: %lu bytes\n", sizeof(Vec2f));
    printf("  Vec3f size: %lu bytes\n", sizeof(Vec3f));
    printf("  GibgoVertex size: %lu bytes\n", sizeof(GibgoVertex));
    printf("\n");

    // Initialize X11 window
    if (!init_x11(&ctx)) {
        fprintf(stderr, "‚ùå X11 initialization failed\n");
        return EXIT_FAILURE;
    }

    // Initialize our HARDWARE-DIRECT graphics system
    if (!init_graphics(&ctx)) {
        fprintf(stderr, "‚ùå Graphics initialization failed\n");
        cleanup(&ctx);
        return EXIT_FAILURE;
    }

    // Run the main loop
    run_main_loop(&ctx);

    // Cleanup
    cleanup(&ctx);

    printf("\nüéâ Hardware-direct graphics demo completed successfully!\n");
    printf("You just controlled a GPU directly - NO DRIVERS INVOLVED!\n");
    return EXIT_SUCCESS;
}

// Note: Actual shader bytecode is provided by shader_data.c
// which is generated by the compile_shaders_hardware.sh script